#import "@preview/whalogen:0.1.0": ce
#set math.equation(numbering: "1")

#let innerproduct(x, y) = $lr(angle.l #x, #y angle.r)$

#align(
  center,
  text(
    17pt,
  )[
      *Symmetry Implementation for Pair Distribution Function*
    ],
)
#align(center)[Max Krummenacher]
#v(20pt)
#align(
  center,
)[
    Bachelor thesis #datetime.today().display("[day].[month].[year]")\
    Draft\
    BSc material science and engineering ETH Zürich\
    supervised by Arkadiy Simonov
  ]
// #pagebreak()

#align(
  center,
)[
  #set par(justify: false)
  *Abstract* \
  Pairs of symmetry related sites in crystals are important for many applications, for example the 3d #sym.Delta\ PDF,
  which is used to determine the structure of disordered crystals.
  In this work a program to determine the multiplicity of such pairs was developed.
  This work explains the mathematics behind crystals, special sites in crystals and pairs of symmetry equivalent positions.
  Examples in 1, 2 and 3 dimensions are shown to explain the concepts and algorithms used to determine pair multiplicity
  and the structure of the program is described.
]

= Introduction

== Disordered Crystals
At finite temperature materials inherently posses some type of disorder. But while gases and liquids posses no long range order, in crystals the 
equilibrium positions of the atoms are arranged in periodic pattern.
But crystals still show a degree of disorder. Most disorder in the crystall is in the thermal motion of the atoms.
But also the formation of vacancies, dislocations and other faults in crystals or magnetic orientations might be a source of disorder.
If a material is degenrate, i.e. the material has many states with simmilar energies, a greater degree of disorder is promoted.

A good example for such structures is the material class of Prussian blue analogues 
(materials with composition $#ce("M[M'(CN)_6]")_text(x)$ where M and M' are metal ions).
Prussian blue analogues generally have an fcc structure.
However, not all hexacyanometallates are occupied as charge neutrality dictates the ratio x between metal ions and hexacyanometallates.
In some Prussian blue analogues such as #ce("Mn^II [Co^III (CN)_6]_⅔") this fraction of vacancies is impossible to arrange in a way that follows
the symmetries of the system. The symmetry of the crystal is broken.

The concept of an average structure simplifies this.
Instead of giving precise information about the positions in the whole crystal the average structure provides probabalistic information about the
occupation of a position. In the example above the probability of occupation of a hexacyanometallate is given by x = ⅔.
But by considering only average structure a lot of information about a material is lost.

In fact, these vacancies are not uniformly distributed throughout the crystal. For example we might expect the vacancies to be more stable if they
are arranged along certain direction or at certain distances. These correlations are very important as they influence the properties of the material.
Such as porosity, diffusion coefficients, absorbtion coefficients and more, which find application ranging from medicine to the development of new
batteries.

== Diffuse Scattering
X-ray diffraction is a common technique to determine the crystal structure as well as the lattice parameters of crystals.
The technique uses the diffraction pattern generated by shining an X-ray beam through a single crystal.
The pattern captured using this method reflects the symmetry of a crystal and is the Fourier transform of the electron density.
The complex structure factor $F(arrow(h))$ can be calculated by:
$ F(arrow(h)) = integral_(RR^3) rho(arrow(x)) exp(2 pi i arrow(h) dot arrow(x)) d x $
However, only the magnitude $I(arrow(h)) = abs(F(arrow(h)))^2 = F(arrow(h)) F^*(arrow(h))$
of the structure factor can be measured in a diffraction experiment.
For perfectly ordered crystals the intensity measured is zero everywhere except at certain points. 
From these diffraction peaks the Laue group of the crystal can be determined.
Using iterative approaches such as charge filpping the phase of the signal can be reconstructed and the average structure can be determined.@superfilp



=== 3D Pair Distribution Function
The 3D pair distribution function (3D-PDF) is a function used to find correlations in structures.
In the application for crystallography it specifically refers to the autocorrelation of the electron density $rho$.

$ text(P D F)(arrow(x)) = integral_(RR^3)rho(arrow(xi))rho(arrow(xi)-arrow(x)) d arrow(xi) $

The PDF essentially shifts the electron density with respect to itself and then compares the shifted function to itsself.
A high value at point $arrow(x)$ means that the structure is highly correlated with a shift by $arrow(x)$.

In diffraction experiments the PDF is convenient as it is easily obtained as the inverse Fourier transform of the intensities measured.
As such no calculation of the phase factors is necessary.

$
cal(F) ^(-1)(I(arrow(h))) &= cal(F)^(-1) [cal(F)(rho(arrow(x))) cal(F)^*(rho(arrow(x)))] \
  &= cal(F)^(-1) [cal(F)(rho(arrow(x))) cal(F)(rho(-arrow(x)))]\
  &= rho(arrow(x)) * rho(-arrow(x))
$

The diffraction pattern from an experiment using a disordered crystal not only contains the bragg peaks but a diffuse pattern inbetween the peaks.
This diffuse part of the diffraction pattern contains information about the correlations described in the section on disordered crystals.
If the average structure is known the difference between the average PDF and PDF calculated from the measured pattern can be formed.
This function is called the difference pair distribution function #sym.Delta PDF.

The PDF and #sym.Delta PDF can be calculated from measurements from powder diffraction. This, however, leads to a loss of information because 
powder diffraction inherently averages the measurement radially.
...

The #sym.Delta PDF can be used by programms like Yell to find the local correlations of structure.
This is where the main work of the programm comes in. The programm Yell needs to be given the multiplicity of pairs in a crystal to properly expand
the PDF


= The Project
// TODO
// what I've done
// what will come in the report.


= Mathematical Description of Crystals
In the following sections the descibed spaces is assumed be three dimensional, but all concepts can trivially be extended to one and two spaces.
Higher dimensional spaces are possible, but exceed the scope of this work.

A Euclidean space is an affine space with a scalar product.
I simple terms an affine space is a vector space who's orgin is forgotten allowing translations to be part of a linear transformation. @Berger_2004
The scalar product then allows for the calculation of distances and angles, producing a Euclidean space from an affine space.

An affine space consits of an associated point space $A$ and an associated vectors space $arrow(A)$.
These can be thought of as a collection of points and the group of translations acting on them.
For vectors the notation $bold(v) in arrow(A)$, for a translation from point $X in A$ to $Y in A$ the notation $arrow(A B)$ used,
this can also be thought of as map $arrow(dot dot): A times A -> arrow(A)$.

In the point space there is one special position $O$ which is the point relative to which all coordinates are given.
The coordinates of a point is then given in terms of a translation $arrow(v) in arrow(A)$ away from the origin,
for which we know how to work with coordinates from linear algebra.
Thus we can assign a coordinate triple to a point $P$ based on the position vector $arrow(O P)$. 
Note that to specify a basis for an affine space a basis for the associated vector space and an origin need to be specified.

A general linear transformation of a point $X$ can then be described by a linear transformation of the position vector plus a translation.

Following the convention used by the International Table for Crystallography the transformation will be notated in the following way:
$ cal(Q) = (bold(Q), bold(q)) $
$ arrow(O tilde(X)) = arrow(O cal(Q) X) = bold(Q) arrow(O X) + bold(q) $

Note that the inversion of $cal(Q)$ is given by $cal(Q)^(-1) = (bold(Q)^(-1), -bold(Q)^(-1) bold(q))$, the composition of two translations is given by 
$cal(Q) cal(P) = (bold(Q P), bold(Q p + q))$ and the identity is given by $cal(I) = (bold(I), bold(o))$
Proofs for these equations as well as associativity are given in the appendix.

The scalar product is defined on the vector space with the usual axioms for the scalar product.

The coordinates of the affine space are called cartesians, if the coefficients of the associated vector space are given in an orthonormal basis.
In this case the scalar product is the dot product.

If the coordinates are not cartesian the scalar product is given by:
$ innerproduct(bold(v), bold(w)) = bold(v)^T bold(G) bold(w) $
Where G is a symmetric 3 by 3 matrix know as the matric tensor.
The norm is naturally induced by the scalar product $norm(bold(v)) = sqrt(innerproduct(bold(v), bold(v)))$
and distances between points $P, Q$ can be measured by takeing the norm of the translation vector between them $d(P, Q) = norm(arrow(P Q))$.

== Crystals Structures
In crystallography a crystal structure is an ordered structure which fulfills three linearly independent translation symmetries
$bold(t)_1, bold(t)_2, bold(t)_3 in RR^3$.

The basis for the vector space can then be given in terms of these vectors. However, in crystallography the basis is some times given in terms of
combinations of these vectors for an easier description of symmetries in the crystal structure.
Since we do not care about orientation of the space we can give the basis in terms of the length of the basis vectors $a, b, c$ and
the angles between them $alpha, beta, gamma$ known as fractional coordinates.

The metric tensor $G$ can be calculated from these values in the following way:
$
G = mat(
  bold(a) dot bold(a), bold(a) dot bold(b), bold(a) dot bold(c);
  bold(b) dot bold(a), bold(b) dot bold(b), bold(b) dot bold(c);
  bold(c) dot bold(a), bold(c) dot bold(b), bold(c) dot bold(c);
) = mat(
  a^2, a b cos(gamma), a c cos(beta);
  b a cos(gamma), b^2, b c cos(alpha);
  c a cos(beta), c b cos(alpha), c^2;
)
$


=== Isomerties
Isometries are distance and angle preserving transformations on a collection of points and can be represented by an affine transformation.
// They can be classified into the following categories:
// - *The Identity* the symmetry which leaves the structure unchanged.
// - *Translation symmetries* symmetries which.
For an affine transformation to be an isometry the following statement must hold for all $a, b in P$:
$
d(X, Y) &= d(cal(Q)X, cal(Q)Y)\
norm(accent(X Y, arrow)) &= norm(accent(cal(Q)X cal(Q)Y, arrow))\
&= norm(bold(Q) accent(O Y, arrow) + bold(q) - bold(Q) accent(O X, arrow) - bold(q))\
&= norm(bold(Q)(accent(O Y, arrow) - accent(O X, arrow)))\
&= norm(bold(Q) accent(X Y, arrow))
$

As expected the translation vector $q$ is free as a translation doesn't affect the distances between points.

Since X and Y are arbitrary points the vector $v$ between them is too.
Using the definition of the metric:
$
norm(bold(v)) &= norm(bold(Q v))\
norm(bold(v))^2 &= norm(bold(Q v))^2\
bold(v)^T bold(G) bold(v) &= (bold(Q v))^T bold(G) (bold(Q v))\
&= bold(v)^T bold(Q)^T bold(G) bold(Q) bold(v)
$

Since $bold(v)$ is arbitrary this equation leads to the following condition on $bold(Q)$:
$ bold(G) = bold(Q)^T bold(G) bold(Q) $
Which might me more familiar to the reader in cartesian coordinates where $bold(G) = bold(I)$
$ bold(I) = bold(Q)^T bold(Q) $
Which is the condition for $bold(Q)$ to be orthagonal.
Orthagonal matrices have determinant $plus.minus 1$ the same is the case for the transformation matrix by:
$
det(bold(G)) = det(bold(Q)^T bold(G) bold(Q)) = det(bold(Q)^T) det(bold(G)) det(bold(Q))\
1 = det(bold(Q)^T) det(bold(Q)) = det(bold(Q))^2\
=> det(bold(Q)) = plus.minus 1
$

In addition to the orthogonality condition we also know that the matrix $bold(Q)$ must map integer vectors to integer vectors.
In fact for all spacegroups a represenatation using only matrices from ${-1, 0, 1}^3$ can be found.

For applications in computation it is necessary to find a finite representation of space groups.
One such representation can be found in what will be referred to as the normalized space group of $frak(G)$ denoted $tilde(frak(G))$.
It is defined as the quotient group of $frak(tilde(G))=frak(G) slash frak(T)$ where $frak(T) = {(bold(I), bold(v))| v in ZZ^3}$ is 
the group generated by translations along the basis vectors.
In the same fashion the quotient vector space $tilde(arrow(A)) = arrow(A) slash {vec(x, y, z) | x, y, z in ZZ}$
and the quotient point space $tilde(A) = A slash {vec(x, y, z) | x, y, z in ZZ}$ is defined.
The order of a space group is defined in such terms.


== Wyckoff Positions
In simple terms Wyckoff positions describe how many times a site occurs in a unitcell and what symmetries it must follow.

Mathematically a Wyckoff position can be described by an orbit and a stabilizer.
An orbit $O_frak(G)(P) = {cal(G) P | cal(G) in frak(G)}$  is the set of points which the point $P$ is mapped to by elements of the group $frak(G)$.
The stabilizer $S_frak(G)(P) = {cal(G) | cal(G) P = P | cal(G) in frak(G)}$ is the subgroup of $frak(G)$ for which the point $P$.
Wyckoff sites are commonly given in terms of their position in the unit cell.
Thus, the normalized space group must be used to determine their multiplicity.

The multiplicity $n$ of a site is given by $abs(O_tilde(frak(G))(P))$ and the site symmetry at point $P$ is given by $S_tilde(frak(G))(P)$.

A position $P$ is called general if the $S_tilde(frak(G))(P)$ only contains the identity. By the orbit stabilizer theorem its multiplicity is $abs(tilde(frak(G)))$ the order of the spacegroup $frak(G)$.

A special position $P$ is a position with a nontrivial stabilizer $S_tilde(frak(G))(P)$. Any object at the point $P$ in crystal must at least have an internal symmetry of its site symmetry, otherwise the symmetry of the crystal is broken.

== Pairs in Crystals
For this work only pairs between symmetry equivalent positions are considered.
Let $P$ be a point in a lattice and $bold(p)$ be a vector from $P$ to a symmetry related position $tilde(P) = cal(G) P$ for some $cal(G) in frak(G)$
where $frak(G)$ is the space group of the crystal.
Then we can describe this pair $P$ in terms of $(P_1, P_2)$. The action of $cal(G)$ on a pair is then defined by:
$
tilde(P) = cal(G) P = (cal(G)P_1, cal(G)P_2)
$
Note that this describes ordered pairs. This can be remedied by defining the following equivalence relation:
$ p ~ q <=> (P_1 = Q_1 and P_2 = Q_2) or (P_1 = Q_2 and P_1 = Q_2) $

Let the expansion $E_frak(G)(p))$ be the set of all symmetry equivalent pairs to the pair $(P, bold(p))$. The expansion of a point contains
two types of pairs. The first type is generated by the stabilizer of $P$.
By definition any element of the stabilizer of $P$ does not change the point $P$. These pairs are of the form 

= Examples of Pair Multiplicities

== One-dimensional Examples
In the one-dimensional case there are only two space groups. 

=== Line group p1
#figure(
  image("figs/p1.svg"),
  caption: [Pairs in line group p1],
)<p1>
In p1 all symmerty operations are translations by multiples of the lattice vector $arrow(l)$, it is isomorphic to $(ZZ, +)$.
Thus all pairs of symmetry related position can be uniquely described by a position within the unit cell and the translation $n arrow(l)$ between them.
Figure @p1 shows how starting from one position there are two possibilities to construct each type of pair.
Thus, the multiplicity of such any pair is 2. Per unit cell there is one starting position $bold(p)$ 
with the paired position at $bold(p') = bold(p) + n arrow(l)$.

=== Line group p1m
In p1m additionaly to the translations by multiples of the lattice $arrow(l)$ there are mirror operations which mirror the line at positions $bold(m) + n arrow(l)$. This group is isomorphic to the direct product $(ZZ, +) times ({-1, 1}, dot)$.
In p1m there are two Wyckoff positions.
The general positions with Wyckoff multiplicity 2, in other words it exists twice per unit cell, and the special positions at $bold(m)$ and $bold(m) + 1/2 arrow(l)$, which have Wyckoff multiplicty 1 and a site symmetry m.
Here the calculation of the pair multiplicity must be treated differently for origins at general and special positions.

#figure(
  image("figs/p1m_g.svg"),
  caption: [Pairs of general positions in line group p1m],
)
The general position has site symmetry 1. For general positions the pairs can be categorized further into two categories.
For pairs of type $n arrow(l)$, there exist two possibilities for each pair one in the positive direction on in the negative.
Since there are two starting positions per unitcell the pair multiplicity is 4.
For pairs which do not occur over a basis vector length there only is one possibility for the construction of such a pair.
Considering the two possible starting positions, the pair multiplicity is 2.

#figure(
  image("figs/p1m_s.svg"),
  caption: [Pairs of special positions in line group p1m],
)
Special positions in contrast have site symmetry m. Thus, each pair can be built once in each direction.
Since the Wyckoff multiplicity is 1, pairs builtfrom special positions have pair multiplicity 2.

== Two-dimensional Example
#figure(
  image("figs/p2mg.svg"),
  caption: [Pairs in the wallpaper group p2mg],
)
As a next example consider pairs of positions on the mirror axis of the wallpaper group p2mg.
The coordinates of such a point is ($x, 1/4$) with its symetry equivalent point at ($1-x, 3/4$).

== Three-dimensional Example
In three dimensions the 
// TODO



= Programm
== Affine space implementation
All coordinates used in the program are rational numbers implemented as pair of `i32`, which are always represented in reduced form and positive denominator. Rational numbers were chosen instead of floating point numbers to allow for exact caluculations and comparisons of coordinates.
From triplets of rational numbers vectors `Vec3` and positions `Pos3` and operations needed for them to form an affine space were defined.

Simmilarly matrices `Mat3` and affine transformations `Affine3` were implemented, where a matrix is represented as list of nine rational numbers and an affine trasformation is represented as pair of a matrix and a vector, as described above.

Additionally, a struct `Bounds3` was defined. It is used for the implentation of the remainder. Here 3 integers were chosen as it only makes sense to 
produce integer bounds in a crystall lattice.
The remainder operation was defined on positions `Pos3` such that each the result of the operation `Pos3(x', y', z') = Pos3(x, y, z) % Bounds3(a, b, c)`
produces coordinates `x'`, `y'`and `z'` in the ranges $[0, a)$, $[0, b)$ and $[0, c)$ respectively.
Note that if $a, b, c = 1$ the remainder produces positions in the unit cell.
For vectors `Vec3` the operation `Vec3(x', y', z') = Vec3(x, y, z) % Bounds3(a, b, c)` such that it produces coefficients
`x'`, `y'`and `z'` in the ranges $(-a/2, a/2]$, $(-b/2, b/2]$ and $(-c/2, c/2]$ respectively.
The different implementation of the remainder for `Vec3` allows vectors to be represented by the shourtest vector in the equivalence class. 
The remainder operation was defined on affine transformations `Affine3` too. Here the operation leaves the matrix untouched but takes the remainder of the associated vector.

== Space group implementation
The space group is represented as the normalized space group where all operations take place modulo `Bounds3`.
Using this representation there is a finite list of symmetry operations and
all other symmetries can be easily generated by the multiplication of integer translation with the operations already present.
The space group can be constructed from a list of generators by the following simple algorithm.
```rust
bounds = Bounds3(1, 1, 1)
symmetries = []

for op in generators {
  normalized_op = op % bounds
  if normalized_op not in symmerties {
    symmetries.push(normalized_op)
  }
}

added_new = true

while added_new {
  added_new = false
  len = len(symmetries)

  for i in 0..len {
    new_op = symmetries[i] * symmetries[i] % bounds
    if new_op not in symmerties {
      symmetries.push(new_op)
      added_new = true
    }

    for j in i..len {
      new_op = symmetries[i] * symmetries[j] % bounds
      if new_op not in symmerties {
        symmetries.push(new_op)
        added_new = true
      }

      new_op = symmetries[j] * symmetries[i] % bounds
      if new_op not in symmerties {
        symmetries.push(new_op)
        added_new = true
      }
    }
  }
}
```

This algorithm first brings the generator into the form required and checks for duplicates.
Then it tries to close the group by going through all multiplications of elements. If the new operation is not present it is appended to the list.
This process is repeated until no new operation was added to the list in one pass through.
This algorithm is far from optimal, but because of the small numbers of element in normalized space groups this is of no concern.
If the wrong symmetries are supplied the group migth not be finitely closable. In this case the algoithm described above results in an infinite loop.
As a safety precausion a upper limmit of 10000 iterations was placed on the outer while loop.
The bounds and the operations are collected in struct called `Isometrygroup`.

== Wyckoff positions

For a position in the unit cell the Wyckoff position can be calculated from the starting position `pos` and the symmetry operations `symmetries` by the following process.

```rust
bounds = Bounds3(1, 1, 1)
pos = pos % bounds
orbit = [pos]
stabilizer = []

for sym in symmetries {
  new_pos = sym * pos % bounds
  if new_pos == pos {
    stabilizer.push(sym)
  } else if new_pos not in orbit {
    orbit.push(new_pos)
  }
}
```

The Wyckoff multiplicity is the length of the orbit as they represent all symmetry equivalent positions in the unitcell.
A struct called `Site` is used to collect the starting position, the orbit and the stabilizer.


== Pair implementation
In the implementation exists a struct called `Pair` which is used to store the information about a pair.
Its constructor takes the starting position, the vector associated with the pair and the isometry group.
After translating the starting position into the unitcell. The `Site` is constructed from the starting position and the space group.
The pair vector is added to the starting position and the resulting position is checked against the orbit of the `Site`.
Then the following algorithm is applied to the pair to determine its expansion:
```rust
expansion = []
p1 = origin_pos
p2 = origin_pos + vec

for op in symmetries {
  new_p1 = (op * p1) % bounds;
  new_p2 = (op * p2) % bounds;
  if new_p1 == origin_pos and new_pos2 not in expansion {
    expansion.push(new_p2)
  }
  if new_p2 == origin_pos and new_pos1 not in expansion {
    expansion.push(new_p1)
  }
}
```
This algorithm applies each operation to the starting and end position of the pair and then checks either one of the positions was mapped to the
original starting position, if so it appends the other position to the expansion.

The pair multiplicity now can be calculated by multiplying the length of the expansion and the length of the orbit of the pairs.

== Program
// TODO


= Appendix


*Claim*
$cal(Q) cal(P) = (bold(Q P), bold(Q p + q))$ is the formula for the composition of affine transformations.

*Proof*
Let $X$ be any arbitrary point.
$
cal(Q) cal(P) arrow(O X) &= cal(Q) (bold(P) arrow(O X) + bold(p))\
&= bold(Q)(bold(P) arrow(O X) + bold(p)) + bold(q)\
&= (bold(Q)bold(P)) arrow(O X) + (bold(Q) bold(p) + bold(q))\
&=(bold(Q P), bold(Q p + q)) arrow(O X)
$


*Claim*
The inverse of $cal(Q) = (bold(Q), bold(q))$ is given by $cal(Q)^(-1) = (bold(Q)^(-1), -bold(Q)^(-1) bold(q))$.

*Proof*
Consider the following composition using the formula proofed above.
$
cal(Q)cal(Q)^(-1) &= (bold(Q), bold(q)) (bold(Q)^(-1), -bold(Q)^(-1) bold(q))\
&= (bold(Q) cal(Q)^(-1), bold(q) - bold(Q)bold(Q)^(-1) bold(q))\
&= (bold(I), bold(q) -bold(q)),
&= cal(I)
$

*Definition*
$H$ is a normal subgroup of $G$ if $g h g^(-1) in H$ for all $g in G$ and $h in H$.

*Claim*
Let $frak(H)$ be a spacegroup and $frak(T) = { (bold(I), bold(v)) ; bold(v) in ZZ^3 }$ the group of interger translation.
Then $frak(T)$ is a normal subgroup of $frak(H)$.

*Proof*
Let $cal(H) in frak(H)$ be an arbitrary symmetry element and $cal(T) in frak(T)$ be an arbitrary integer translation.
$
cal(H)cal(T)cal(H)^(-1) &= (bold(H), bold(h))(bold(I), bold(t))(bold(H)^(-1), -bold(H)^(-1)bold(q))\
&= (bold(H), bold(h))(bold(H)^(-1), -bold(H)^(-1)bold(q) + bold(t))\
&= (bold(H) bold(H)^(-1), bold(H)(-bold(H)^(-1)bold(q) + bold(t)) + bold(q))\
&= (bold(I), bold(H)bold(t))
$

In order to be a valid space group $bold(H)$ must map integer vector to integer vector. Thus $cal(H)cal(T)cal(H)^(-1) = (bold(I), bold(H)bold(t))$
is an element of $frak(T)$. qed

#bibliography("ref.bib")
